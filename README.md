# 图像抖动算法二值化
需求主要是打印机想打印图片，但只能打印黑白，正常二值化图片失真太大，需要一种黑白二值化失真少的转化方式。

这种方法学名叫图片抖动算法，可以在大小不变的情况下，将图片颜色转换成黑白点阵密度


算法核心思想：先将图片RGB转成灰度  我使用的是 (R+G+B)/3   区间是[0-255]==>[黑,白]

转成灰度后就要二值化了，常用的思维是使用阈值来二值化,效果很差。

然后我想的是获取一个点的灰度，将[0-255]的灰度映射成[0-8] 9个尺度，然后将一个点的灰度 扩大成9个格子，灰度越低 涂黑的格子越多。
这个效果很理想，但是有一个很大的问题，他会将图片的长宽都扩大3倍，应用到打印机局限性就出来了。

接下来在网络上看到了图像抖动算法，他不需要扩张，他们算法思想是：不是一个一个点考虑，而是考虑一小片区域，这个区域内的点通过来处理

```
bayer=[[0, 48, 12, 60, 3, 51, 15, 63], 
                [32, 16, 44, 28, 35, 19, 47, 31],
                [8, 56, 4, 52, 11, 59, 7, 55],
                [40, 24, 36, 20, 43, 27, 39, 23],
                [2, 50, 14, 62, 1, 49, 13, 61],
                [34, 18, 46, 30, 33, 17, 45, 29],
                [10, 58, 6, 54, 9, 57, 5, 53],
                [42, 26, 38, 22, 41, 25, 37, 21]]
```
这里使用的是 M3矩阵

```
if (image[y][x]>>2) > bayer[y&7][x&7] then 打一白点 else 打一黑点
```
     
 
 
**image[y][x]表示这个点的灰度值,>>2的原因是原本的灰度是256级的，但是我们bayer矩阵能处理的是[0-63] 所以要降到64级灰度。**         
                
最终效果 不知道怎么传图片，反正很理想

详情见这三篇文章：
抖动算法小议1、2、3

http://blog.csdn.net/coolbacon/article/details/4041988

http://blog.csdn.net/coolbacon/article/details/4042054

http://blog.csdn.net/coolbacon/article/details/4042122
